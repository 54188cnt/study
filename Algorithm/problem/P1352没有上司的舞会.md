## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入格式

输入的第一行是一个整数 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。

第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。

## 输出格式

输出一行一个整数代表最大的快乐指数。

## 输入输出样例 #1

### 输入 #1

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 输出 #1

```
5
```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。

## 代码
```java
import java.io.*;
import java.util.*;

public class Main {
	// 人数
	static int n;
	// 幸福指数
	static int[] r;
	// 上司关系
	static List<Integer>[] g;
	// 动态规划数组
	static int[][] f;
	
	static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
	
	static int nextInt() throws IOException {
		in.nextToken();
		return (int) in.nval;
	}
	
	public static void main(String[] args) throws IOException {
		n = nextInt();
		
		r = new int[n + 1];
		for(int i = 1;i <= n;++i) {
			r[i] = nextInt();
		}
		
		g = new ArrayList[n + 1];
		Arrays.setAll(g, i -> new ArrayList<>());
		
		// 寻找顶级上司
		boolean[] hasParent = new boolean[n + 1];
		for(int i = 0;i < n - 1;++i) {
			int l = nextInt();
			int k = nextInt();
			g[k].add(l);
			hasParent[l] = true;
		}
		
		int root = 1;
		while(root <= n && hasParent[root]) root++;
		
		f = new int[n+1][2];
		dfs(root);
		System.out.println(Math.max(f[root][0], f[root][1]));
	}
	
	static void dfs(int u) {
		f[u][1] = r[u];
		for(int v: g[u]) {
			dfs(v);
			f[u][0] += Math.max(f[v][0], f[v][1]);
			f[u][1] += f[v][0];
		}
	}
}
```