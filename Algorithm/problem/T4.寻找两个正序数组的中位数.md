题目：
![](../assets/algorithm/problem/T4.寻找两个正序数组的中位数.png)

代码（两种方式）：
算法一：二分法找第k小  $O(\log(m+n))$ 
```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int len = nums1.length + nums2.length;
    return len % 2 == 0 ? (findKth(nums1, nums2, len / 2) + findKth(nums1, nums2, len / 2 + 1)) / 2.0 
            : (double) findKth(nums1, 0, nums2, 0, len / 2 + 1);
}

private int findKth(int[] a, int[] b, int k) {
    // 简化逻辑保证a为短数组
    if (a.length > b.length) {
        return findKth(b, a, k);
    }
    int m = a.length, n = b.length;
    
    // 二分查找 a 中的分割点i
    // i的含义是a[0...i]（共 i+1 个元素）被分到左边
    // b[0...j]（共 j+1 个元素）被分到右边
    // 此时有 j + 1 = k - (i + 1)，即 j = k - i - 2
    // i 的有效范围为 (-1, min(m, k)) 直接开区间二分

    // 其实更像数值二分，但是这里 a[i] 的含义是 a[0...i] 被分到左边
    int l = -1, r = Math.min(m, k);
    while(l + 1 < r) {
        int i = l + (r - l) / 2;
        int j = k - i - 2;
        // ai = a[i], ai1 = a[i+1]
        // bj = b[j], bj1 = b[j+1]
        
        // Q: 什么时候i左移，什么时候i右移
        // A: 
        
        // 边界值
        
    }
}
```

算法二：划分数组 $O(\log(\min(m, n)))$ 
