题目：
![](../assets/algorithm/problem/T4.寻找两个正序数组的中位数.png)

代码（两种方式）：
算法：划分数组(用到了数值二分思想) $O(\log(\min(m, n)))$ 
```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int len = nums1.length + nums2.length;
    return len % 2 == 0 ? (findKth(nums1, nums2, len / 2) + findKth(nums1, nums2, len / 2 + 1)) / 2.0 
            : (double) findKth(nums1, nums2, len / 2 + 1);
}

private int findKth(int[] a, int[] b, int k) {
    // 简化逻辑保证a为短数组
    if (a.length > b.length) {
        return findKth(b, a, k);
    }
    int m = a.length, n = b.length;
    
    // 二分查找 a 中的分割点i
    // i的含义是a[0...i]（共 i+1 个元素）被分到左边
    // b[0...j]（共 j+1 个元素）被分到右边
    // 此时有 j + 1 = k - (i + 1)，即 j = k - i - 2
    // i 的有效范围为 (-1, min(m, k)) 直接开区间二分

    // 其实更像数值二分，但是这里 a[i] 的含义是 a[0...i] 被分到左边
    int l = -1, r = Math.min(m, k);
    while(l + 1 < r) {
        int i = l + (r - l) / 2;
        int j = k - i - 2;
        // ai = a[i], ai1 = a[i+1]
        // bj = b[j], bj1 = b[j+1]
        
        // Q: 什么时候i左移，什么时候i右移
        // A: ai <= bj1 (=是为了保证 i 为最大值)

        // 边界值
        int ai = i < 0 ? Integer.MIN_VALUE : a[i];
        int bj1 = (j + 1 >= n) ? Integer.MAX_VALUE : b[j + 1];
        
        if(ai <= bj1) {
            l = i;
        }else {
            r = i;
        }
    }
    
    // 二分查找后结果：l 是最大的满足 a[i] <= b[j+1] 的 i
    int i = l;
    int j = k - i - 2;
    
    // 获取 a[i] 和 b[j]
    // 处理边界值：l的范围为[-1, min(m,k) - 1]
    // 所以 i < 0 时，a[i] = Integer.MIN_VALUE
    // 当 i = k-1 时 j=-1 ，b[j] = Integer.MIN_VALUE
    int ai = i < 0 ? Integer.MIN_VALUE : a[i];
    int bj = j < 0 ? Integer.MIN_VALUE : b[j];
    
    // 第 k 小应为最左边的最大值
    return Math.max(ai, bj);
}
```
